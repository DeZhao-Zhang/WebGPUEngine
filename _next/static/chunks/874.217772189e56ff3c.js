(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[874],{5671:function(e,n,t){"use strict";t.d(n,{T:function(){return l}});var a=t(5893),r=t(9008),i=t.n(r),o=t(1163),s=t(7294),u=t(9147),c=t.n(u);t(7319);let d=e=>{let n=(0,s.useRef)(null),r=(0,s.useMemo)(()=>e.sources.map(e=>{let{name:n,contents:r}=e;return{name:n,...function(e){let n;let r=null;{r=document.createElement("div");let i=t(4631);n=i(r,{lineNumbers:!0,lineWrapping:!0,theme:"monokai",readOnly:!0})}return{Container:function(t){return(0,a.jsx)("div",{...t,children:(0,a.jsx)("div",{ref(t){r&&t&&(t.appendChild(r),n.setOption("value",e))}})})}}}(r)}}),e.sources),u=(0,s.useRef)(null),d=(0,s.useMemo)(()=>{if(e.gui){let n=t(4376);return new n.GUI({autoPlace:!1})}},[]),l=(0,o.useRouter)(),m=l.asPath.match(/#([a-zA-Z0-9\.\/]+)/),[p,f]=(0,s.useState)(null),[h,g]=(0,s.useState)(null);return(0,s.useEffect)(()=>{m?g(m[1]):g(r[0].name),d&&u.current&&u.current.appendChild(d.domElement);let t={active:!0},a=()=>{t.active=!1};try{let i=n.current,o=e.init({canvas:i,pageState:t,gui:d});o instanceof Promise&&o.catch(e=>{console.error(e),f(e)})}catch(s){console.error(s),f(s)}return a},[]),(0,a.jsxs)("main",{children:[(0,a.jsxs)(i(),{children:[(0,a.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n            .CodeMirror {\n              height: auto !important;\n              margin: 1em 0;\n            }\n\n            .CodeMirror-scroll {\n              height: auto !important;\n              overflow: visible !important;\n            }\n          "}}),(0,a.jsx)("title",{children:"".concat(e.name," - WebGPU Samples")}),(0,a.jsx)("meta",{name:"description",content:e.description}),(0,a.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,a.jsxs)("div",{children:[(0,a.jsx)("h1",{children:e.name}),(0,a.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://github.com/".concat("webgpu/WebGPUEngine","/tree/main/").concat(e.filename),children:"See it on Github!"}),(0,a.jsx)("p",{children:e.description}),p?(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("p",{children:"Is WebGPU Enabled?"}),(0,a.jsx)("p",{children:"".concat(p)})]}):null]}),(0,a.jsxs)("div",{className:c().canvasContainer,children:[(0,a.jsx)("div",{style:{position:"absolute",right:10},ref:u}),(0,a.jsx)("canvas",{ref:n})]}),(0,a.jsxs)("div",{children:[(0,a.jsx)("nav",{className:c().sourceFileNav,children:(0,a.jsx)("ul",{children:r.map((e,n)=>(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#".concat(e.name),"data-active":h==e.name,onClick(){g(e.name)},children:e.name})},n))})}),r.map((e,n)=>(0,a.jsx)(e.Container,{className:c().sourceFileContainer,"data-active":h==e.name},n))]})]})},l=e=>(0,a.jsx)(d,{...e})},6874:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return S}});var a,r,i=t(5671),o="// A storage buffer holding an array of atomic<u32>.\n// The array elements are a sequence of red, green, blue components, for each\n// lightmap texel, for each quad surface.\n@group(1) @binding(0)\nvar<storage, read_write> accumulation : array<atomic<u32>>;\n\n// The output lightmap texture.\n@group(1) @binding(1)\nvar lightmap : texture_storage_2d_array<rgba16float, write>;\n\n// Uniform data used by the accumulation_to_lightmap entry point\nstruct Uniforms {\n  // Scalar for converting accumulation values to output lightmap values\n  accumulation_to_lightmap_scale : f32,\n  // Accumulation buffer rescaling value\n  accumulation_buffer_scale : f32,\n  // The width of the light\n  light_width : f32,\n  // The height of the light\n  light_height : f32,\n  // The center of the light\n  light_center : vec3f,\n}\n\n// accumulation_to_lightmap uniforms binding point\n@group(1) @binding(2) var<uniform> uniforms : Uniforms;\n\n// Number of photons emitted per workgroup\noverride PhotonsPerWorkgroup : u32;\n\n// Maximum value that can be added to the accumulation buffer from a single photon\noverride PhotonEnergy : f32;\n\n// Number of bounces of each photon\nconst PhotonBounces = 4;\n\n// Amount of light absorbed with each photon bounce (0: 0%, 1: 100%)\nconst LightAbsorbtion = 0.5;\n\n// Radiosity compute shader.\n// Each invocation creates a photon from the light source, and accumulates\n// bounce lighting into the 'accumulation' buffer.\n@compute @workgroup_size(PhotonsPerWorkgroup)\nfn radiosity(@builtin(global_invocation_id) invocation_id : vec3u) {\n  init_rand(invocation_id);\n  photon();\n}\n\n// Spawns a photon at the light source, performs ray tracing in the scene,\n// accumulating light values into 'accumulation' for each quad surface hit.\nfn photon() {\n  // Create a random ray from the light.\n  var ray = new_light_ray();\n  // Give the photon an initial energy value.\n  var color = PhotonEnergy * vec3f(1, 0.8, 0.6);\n\n  // Start bouncing.\n  for (var i = 0; i < (PhotonBounces+1); i++) {\n    // Find the closest hit of the ray with the scene's quads.\n    let hit = raytrace(ray);\n    let quad = quads[hit.quad];\n\n    // Bounce the ray.\n    ray.start = hit.pos + quad.plane.xyz * 1e-5;\n    ray.dir = normalize(reflect(ray.dir, quad.plane.xyz) + rand_unit_sphere() * 0.75);\n\n    // Photon color is multiplied by the quad's color.\n    color *= quad.color;\n\n    // Accumulate the aborbed light into the 'accumulation' buffer.\n    accumulate(hit.uv, hit.quad, color * LightAbsorbtion);\n\n    // What wasn't absorbed is reflected.\n    color *= 1 - LightAbsorbtion;\n  }\n}\n\n// Performs an atomicAdd() with 'color' into the 'accumulation' buffer at 'uv'\n// and 'quad'.\nfn accumulate(uv : vec2f, quad : u32, color : vec3f) {\n  let dims = textureDimensions(lightmap);\n  let base_idx = accumulation_base_index(vec2u(uv * vec2f(dims)), quad);\n  atomicAdd(&accumulation[base_idx + 0], u32(color.r + 0.5));\n  atomicAdd(&accumulation[base_idx + 1], u32(color.g + 0.5));\n  atomicAdd(&accumulation[base_idx + 2], u32(color.b + 0.5));\n}\n\n// Returns the base element index for the texel at 'coord' for 'quad'\nfn accumulation_base_index(coord : vec2u, quad : u32) -> u32 {\n  let dims = textureDimensions(lightmap);\n  let c = min(vec2u(dims) - 1, coord);\n  return 3 * (c.x + dims.x * c.y + dims.x * dims.y * quad);\n}\n\n// Returns a new Ray at a random point on the light, in a random downwards\n// direction.\nfn new_light_ray() -> Ray {\n  let center = uniforms.light_center;\n  let pos = center + vec3f(uniforms.light_width * (rand() - 0.5),\n                           0,\n                           uniforms.light_height * (rand() - 0.5));\n  let dir = normalize(vec3f(0, -1, 0) + rand_unit_sphere());\n  return Ray(pos, dir);\n}\n\noverride AccumulationToLightmapWorkgroupSizeX : u32;\noverride AccumulationToLightmapWorkgroupSizeY : u32;\n\n// Compute shader used to copy the atomic<u32> data in 'accumulation' to\n// 'lightmap'. 'accumulation' might also be scaled to reduce integer overflow.\n@compute @workgroup_size(AccumulationToLightmapWorkgroupSizeX, AccumulationToLightmapWorkgroupSizeY)\nfn accumulation_to_lightmap(@builtin(global_invocation_id) invocation_id : vec3u,\n                            @builtin(workgroup_id)         workgroup_id  : vec3u) {\n  let dims = textureDimensions(lightmap);\n  let quad = workgroup_id.z; // The workgroup 'z' value holds the quad index.\n  let coord = invocation_id.xy;\n  if (all(coord < dims)) {\n    // Load the color value out of 'accumulation'\n    let base_idx = accumulation_base_index(coord, quad);\n    let color = vec3(f32(atomicLoad(&accumulation[base_idx + 0])),\n                     f32(atomicLoad(&accumulation[base_idx + 1])),\n                     f32(atomicLoad(&accumulation[base_idx + 2])));\n\n    // Multiply the color by 'uniforms.accumulation_to_lightmap_scale' and write it to\n    // the lightmap.\n    textureStore(lightmap, coord, quad, vec4(color * uniforms.accumulation_to_lightmap_scale, 1));\n\n    // If the 'accumulation' buffer is nearing saturation, then\n    // 'uniforms.accumulation_buffer_scale' will be less than 1, scaling the values\n    // to something less likely to overflow the u32.\n    if (uniforms.accumulation_buffer_scale != 1.0) {\n      let scaled = color * uniforms.accumulation_buffer_scale + 0.5;\n      atomicStore(&accumulation[base_idx + 0], u32(scaled.r));\n      atomicStore(&accumulation[base_idx + 1], u32(scaled.g));\n      atomicStore(&accumulation[base_idx + 2], u32(scaled.b));\n    }\n  }\n}\n",s="// The lightmap data\n@group(1) @binding(0) var lightmap : texture_2d_array<f32>;\n\n// The sampler used to sample the lightmap\n@group(1) @binding(1) var smpl : sampler;\n\n// Vertex shader input data\nstruct VertexIn {\n  @location(0) position : vec4f,\n  @location(1) uv : vec3f,\n  @location(2) emissive : vec3f,\n}\n\n// Vertex shader output data\nstruct VertexOut {\n  @builtin(position) position : vec4f,\n  @location(0) uv : vec2f,\n  @location(1) emissive : vec3f,\n  @interpolate(flat)\n  @location(2) quad : u32,\n}\n\n@vertex\nfn vs_main(input : VertexIn) -> VertexOut {\n  var output : VertexOut;\n  output.position = common_uniforms.mvp * input.position;\n  output.uv = input.uv.xy;\n  output.quad = u32(input.uv.z + 0.5);\n  output.emissive = input.emissive;\n  return output;\n}\n\n@fragment\nfn fs_main(vertex_out : VertexOut) -> @location(0) vec4f {\n  return textureSample(lightmap, smpl, vertex_out.uv, vertex_out.quad) + vec4f(vertex_out.emissive, 1);\n}\n",u="// The lightmap data\n@group(1) @binding(0) var lightmap : texture_2d_array<f32>;\n\n// The sampler used to sample the lightmap\n@group(1) @binding(1) var smpl : sampler;\n\n// The output framebuffer\n@group(1) @binding(2) var framebuffer : texture_storage_2d<rgba16float, write>;\n\noverride WorkgroupSizeX : u32;\noverride WorkgroupSizeY : u32;\n\nconst NumReflectionRays = 5;\n\n@compute @workgroup_size(WorkgroupSizeX, WorkgroupSizeY)\nfn main(@builtin(global_invocation_id) invocation_id : vec3u) {\n  if (all(invocation_id.xy < textureDimensions(framebuffer))) {\n    init_rand(invocation_id);\n\n    // Calculate the fragment's NDC coordinates for the intersection of the near\n    // clip plane and far clip plane\n    let uv = vec2f(invocation_id.xy) / vec2f(textureDimensions(framebuffer).xy);\n    let ndcXY = (uv - 0.5) * vec2(2, -2);\n\n    // Transform the coordinates back into world space\n    var near = common_uniforms.inv_mvp * vec4f(ndcXY, 0.0, 1);\n    var far = common_uniforms.inv_mvp * vec4f(ndcXY, 1, 1);\n    near /= near.w;\n    far /= far.w;\n\n    // Create a ray that starts at the near clip plane, heading in the fragment's\n    // z-direction, and raytrace to find the nearest quad that the ray intersects.\n    let ray = Ray(near.xyz, normalize(far.xyz - near.xyz));\n    let hit = raytrace(ray);\n\n    let hit_color = sample_hit(hit);\n    var normal = quads[hit.quad].plane.xyz;\n\n    // Fire a few rays off the surface to collect some reflections\n    let bounce = reflect(ray.dir, normal);\n    var reflection : vec3f;\n    for (var i = 0; i < NumReflectionRays; i++) {\n      let reflection_dir = normalize(bounce + rand_unit_sphere()*0.1);\n      let reflection_ray = Ray(hit.pos + bounce * 1e-5, reflection_dir);\n      let reflection_hit = raytrace(reflection_ray);\n      reflection += sample_hit(reflection_hit);\n    }\n    let color = mix(reflection / NumReflectionRays, hit_color, 0.95);\n\n    textureStore(framebuffer, invocation_id.xy, vec4(color, 1));\n  }\n}\n\n\n// Returns the sampled hit quad's lightmap at 'hit.uv', and adds the quad's\n// emissive value.\nfn sample_hit(hit : HitInfo) -> vec3f {\n  let quad = quads[hit.quad];\n  // Sample the quad's lightmap, and add emissive.\n  return textureSampleLevel(lightmap, smpl, hit.uv, hit.quad, 0).rgb +\n         quad.emissive * quad.color;\n}\n",c="// The linear-light input framebuffer\n@group(0) @binding(0) var input  : texture_2d<f32>;\n\n// The tonemapped, gamma-corrected output framebuffer\n@group(0) @binding(1) var output : texture_storage_2d<{OUTPUT_FORMAT}, write>;\n\nconst TonemapExposure = 0.5;\n\nconst Gamma = 2.2;\n\noverride WorkgroupSizeX : u32;\noverride WorkgroupSizeY : u32;\n\n@compute @workgroup_size(WorkgroupSizeX, WorkgroupSizeY)\nfn main(@builtin(global_invocation_id) invocation_id : vec3u) {\n  let color = textureLoad(input, invocation_id.xy, 0).rgb;\n  let tonemapped = reinhard_tonemap(color);\n  textureStore(output, invocation_id.xy, vec4f(tonemapped, 1));\n}\n\nfn reinhard_tonemap(linearColor: vec3f) -> vec3f {\n  let color = linearColor * TonemapExposure;\n  let mapped = color / (1+color);\n  return pow(mapped, vec3f(1 / Gamma));\n}\n",d="const pi = 3.14159265359;\n\n// Quad describes 2D rectangle on a plane\nstruct Quad {\n  // The surface plane\n  plane    : vec4f,\n  // A plane with a normal in the 'u' direction, intersecting the origin, at\n  // right-angles to the surface plane.\n  // The dot product of 'right' with a 'vec4(pos, 1)' will range between [-1..1]\n  // if the projected point is within the quad.\n  right    : vec4f,\n  // A plane with a normal in the 'v' direction, intersecting the origin, at\n  // right-angles to the surface plane.\n  // The dot product of 'up' with a 'vec4(pos, 1)' will range between [-1..1]\n  // if the projected point is within the quad.\n  up       : vec4f,\n  // The diffuse color of the quad\n  color    : vec3f,\n  // Emissive value. 0=no emissive, 1=full emissive.\n  emissive : f32,\n};\n\n// Ray is a start point and direction.\nstruct Ray {\n  start : vec3f,\n  dir   : vec3f,\n}\n\n// Value for HitInfo.quad if no intersection occured.\nconst kNoHit = 0xffffffff;\n\n// HitInfo describes the hit location of a ray-quad intersection\nstruct HitInfo {\n  // Distance along the ray to the intersection\n  dist : f32,\n  // The quad index that was hit\n  quad : u32,\n  // The position of the intersection\n  pos : vec3f,\n  // The UVs of the quad at the point of intersection\n  uv : vec2f,\n}\n\n// CommonUniforms uniform buffer data\nstruct CommonUniforms {\n  // Model View Projection matrix\n  mvp : mat4x4f,\n  // Inverse of mvp\n  inv_mvp : mat4x4f,\n  // Random seed for the workgroup\n  seed : vec3u,\n}\n\n// The common uniform buffer binding.\n@group(0) @binding(0) var<uniform> common_uniforms : CommonUniforms;\n\n// The quad buffer binding.\n@group(0) @binding(1) var<storage> quads : array<Quad>;\n\n// intersect_ray_quad will check to see if the ray 'r' intersects the quad 'q'.\n// If an intersection occurs, and the intersection is closer than 'closest' then\n// the intersection information is returned, otherwise 'closest' is returned.\nfn intersect_ray_quad(r : Ray, quad : u32, closest : HitInfo) -> HitInfo {\n  let q = quads[quad];\n  let plane_dist = dot(q.plane, vec4(r.start, 1));\n  let ray_dist = plane_dist / -dot(q.plane.xyz, r.dir);\n  let pos = r.start + r.dir * ray_dist;\n  let uv = vec2(dot(vec4f(pos, 1), q.right),\n                dot(vec4f(pos, 1), q.up)) * 0.5 + 0.5;\n  let hit = plane_dist > 0 &&\n            ray_dist > 0 &&\n            ray_dist < closest.dist &&\n            all((uv > vec2f()) & (uv < vec2f(1)));\n  return HitInfo(\n    select(closest.dist, ray_dist, hit),\n    select(closest.quad, quad,     hit),\n    select(closest.pos,  pos,      hit),\n    select(closest.uv,   uv,       hit),\n  );\n}\n\n// raytrace finds the closest intersecting quad for the given ray\nfn raytrace(ray : Ray) -> HitInfo {\n  var hit = HitInfo();\n  hit.dist = 1e20;\n  hit.quad = kNoHit;\n  for (var quad = 0u; quad < arrayLength(&quads); quad++) {\n    hit = intersect_ray_quad(ray, quad, hit);\n  }\n  return hit;\n}\n\n// A psuedo random number. Initialized with init_rand(), updated with rand().\nvar<private> rnd : vec3u;\n\n// Initializes the random number generator.\nfn init_rand(invocation_id : vec3u) {\n  const A = vec3(1741651 * 1009,\n                 140893  * 1609 * 13,\n                 6521    * 983  * 7 * 2);\n  rnd = (invocation_id * A) ^ common_uniforms.seed;\n}\n\n// Returns a random number between 0 and 1.\nfn rand() -> f32 {\n  const C = vec3(60493  * 9377,\n                 11279  * 2539 * 23,\n                 7919   * 631  * 5 * 3);\n\n  rnd = (rnd * C) ^ (rnd.yzx >> vec3(4u));\n  return f32(rnd.x ^ rnd.y) / f32(0xffffffff);\n}\n\n// Returns a random point within a unit sphere centered at (0,0,0).\nfn rand_unit_sphere() -> vec3f {\n    var u = rand();\n    var v = rand();\n    var theta = u * 2.0 * pi;\n    var phi = acos(2.0 * v - 1.0);\n    var r = pow(rand(), 1.0/3.0);\n    var sin_theta = sin(theta);\n    var cos_theta = cos(theta);\n    var sin_phi = sin(phi);\n    var cos_phi = cos(phi);\n    var x = r * sin_phi * sin_theta;\n    var y = r * sin_phi * cos_theta;\n    var z = r * cos_phi;\n    return vec3f(x, y, z);\n}\n",l=t(3560);function m(e){let n=1/l.R3.lenSq(e);return l.R3.mul(l.R3.fromValues(n,n,n),e)}function p(e){let n=l.R3.fromValues(Math.cos(e.rotation)*(e.width/2),0,Math.sin(e.rotation)*(e.depth/2)),t=l.R3.fromValues(0,e.height/2,0),a=l.R3.fromValues(Math.sin(e.rotation)*(e.width/2),0,-Math.cos(e.rotation)*(e.depth/2)),i=e.color instanceof Array?e.color:Array(6).fill(e.color),o=n=>"concave"===e.type?n:l.R3.negate(n);return[{center:l.R3.add(e.center,n),right:o(l.R3.negate(a)),up:t,color:i[r.PositiveX]},{center:l.R3.add(e.center,t),right:o(n),up:l.R3.negate(a),color:i[r.PositiveY]},{center:l.R3.add(e.center,a),right:o(n),up:t,color:i[r.PositiveZ]},{center:l.R3.sub(e.center,n),right:o(a),up:t,color:i[r.NegativeX]},{center:l.R3.sub(e.center,t),right:o(n),up:a,color:i[r.NegativeY]},{center:l.R3.sub(e.center,a),right:o(l.R3.negate(n)),up:t,color:i[r.NegativeZ]}]}(a=r||(r={}))[a.PositiveX=0]="PositiveX",a[a.PositiveY=1]="PositiveY",a[a.PositiveZ=2]="PositiveZ",a[a.NegativeX=3]="NegativeX",a[a.NegativeY=4]="NegativeY",a[a.NegativeZ=5]="NegativeZ";let f={center:l.R3.fromValues(0,9.95,0),right:l.R3.fromValues(1,0,0),up:l.R3.fromValues(0,0,1),color:l.R3.fromValues(5,5,5),emissive:1};class h{constructor(e){this.quads=[...p({center:l.R3.fromValues(0,5,0),width:10,height:10,depth:10,rotation:0,color:[l.R3.fromValues(0,.5,0),l.R3.fromValues(.5,.5,.5),l.R3.fromValues(.5,.5,.5),l.R3.fromValues(.5,0,0),l.R3.fromValues(.5,.5,.5),l.R3.fromValues(.5,.5,.5)],type:"concave"}),...p({center:l.R3.fromValues(1.5,1.5,1),width:3,height:3,depth:3,rotation:.3,color:l.R3.fromValues(.8,.8,.8),type:"convex"}),...p({center:l.R3.fromValues(-2,3,-2),width:3,height:6,depth:3,rotation:-.4,color:l.R3.fromValues(.8,.8,.8),type:"convex"}),f],this.lightCenter=f.center,this.lightWidth=l.R3.len(f.right),this.lightHeight=l.R3.len(f.up);let n=e.createBuffer({size:64*this.quads.length,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!0}),t=new Float32Array(n.getMappedRange()),a=new Float32Array(40*this.quads.length),r=new Uint32Array(9*this.quads.length),i=0,o=0,s=0,u=0,c=0;for(let d=0;d<this.quads.length;d++){var h,g,v,b,y,x,P,G,_,S,w,R,D;let T=this.quads[d],q=l.R3.normalize(l.R3.cross(T.right,T.up));t[s++]=q[0],t[s++]=q[1],t[s++]=q[2],t[s++]=-l.R3.dot(q,T.center);let U=m(T.right);t[s++]=U[0],t[s++]=U[1],t[s++]=U[2],t[s++]=-l.R3.dot(U,T.center);let k=m(T.up);t[s++]=k[0],t[s++]=k[1],t[s++]=k[2],t[s++]=-l.R3.dot(k,T.center),t[s++]=T.color[0],t[s++]=T.color[1],t[s++]=T.color[2],t[s++]=null!==(h=T.emissive)&&void 0!==h?h:0;let C=l.R3.add(l.R3.sub(T.center,T.right),T.up),z=l.R3.add(l.R3.add(T.center,T.right),T.up),L=l.R3.sub(l.R3.sub(T.center,T.right),T.up),E=l.R3.sub(l.R3.add(T.center,T.right),T.up);a[u++]=C[0],a[u++]=C[1],a[u++]=C[2],a[u++]=1,a[u++]=0,a[u++]=1,a[u++]=d,a[u++]=T.color[0]*(null!==(g=T.emissive)&&void 0!==g?g:0),a[u++]=T.color[1]*(null!==(v=T.emissive)&&void 0!==v?v:0),a[u++]=T.color[2]*(null!==(b=T.emissive)&&void 0!==b?b:0),a[u++]=z[0],a[u++]=z[1],a[u++]=z[2],a[u++]=1,a[u++]=1,a[u++]=1,a[u++]=d,a[u++]=T.color[0]*(null!==(y=T.emissive)&&void 0!==y?y:0),a[u++]=T.color[1]*(null!==(x=T.emissive)&&void 0!==x?x:0),a[u++]=T.color[2]*(null!==(P=T.emissive)&&void 0!==P?P:0),a[u++]=L[0],a[u++]=L[1],a[u++]=L[2],a[u++]=1,a[u++]=0,a[u++]=0,a[u++]=d,a[u++]=T.color[0]*(null!==(G=T.emissive)&&void 0!==G?G:0),a[u++]=T.color[1]*(null!==(_=T.emissive)&&void 0!==_?_:0),a[u++]=T.color[2]*(null!==(S=T.emissive)&&void 0!==S?S:0),a[u++]=E[0],a[u++]=E[1],a[u++]=E[2],a[u++]=1,a[u++]=1,a[u++]=0,a[u++]=d,a[u++]=T.color[0]*(null!==(w=T.emissive)&&void 0!==w?w:0),a[u++]=T.color[1]*(null!==(R=T.emissive)&&void 0!==R?R:0),a[u++]=T.color[2]*(null!==(D=T.emissive)&&void 0!==D?D:0),r[c++]=i+0,r[c++]=i+2,r[c++]=i+1,r[c++]=i+1,r[c++]=i+2,r[c++]=i+3,o+=6,i+=4}n.unmap();let B=e.createBuffer({size:a.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(B.getMappedRange()).set(a),B.unmap();let O=e.createBuffer({size:r.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint16Array(O.getMappedRange()).set(r),O.unmap(),this.vertexCount=i,this.indexCount=o,this.vertices=B,this.indices=O,this.vertexBufferLayout=[{arrayStride:40,attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:16,format:"float32x3"},{shaderLocation:2,offset:28,format:"float32x3"}]}],this.quadBuffer=n}}h.sourceInfo={name:"src/sample/cornell/scene.ts".substring(19),contents:"import { vec3 } from 'wgpu-matrix';\ntype Vec3 = vec3.default;\n\nfunction reciprocal(v: Vec3) {\n  const s = 1 / vec3.lenSq(v);\n  return vec3.mul(vec3.fromValues(s, s, s), v);\n}\n\ninterface Quad {\n  center: Vec3;\n  right: Vec3;\n  up: Vec3;\n  color: Vec3;\n  emissive?: number;\n}\n\n//      ─────────┐\n//     ╱  +Y    ╱│\n//    ┌────────┐ │\n//    │        │+X\n//    │   +Z   │ │\n//    │        │╱\n//    └────────┘\nenum CubeFace {\n  PositiveX,\n  PositiveY,\n  PositiveZ,\n  NegativeX,\n  NegativeY,\n  NegativeZ,\n}\nfunction box(params: {\n  center: Vec3;\n  width: number;\n  height: number;\n  depth: number;\n  rotation: number;\n  color: Vec3 | Vec3[];\n  type: 'convex' | 'concave';\n}): Quad[] {\n  //      ─────────┐\n  //     ╱  +Y    ╱│\n  //    ┌────────┐ │        y\n  //    │        │+X        ^\n  //    │   +Z   │ │        │ -z\n  //    │        │╱         │╱\n  //    └────────┘          └─────> x\n  const x = vec3.fromValues(\n    Math.cos(params.rotation) * (params.width / 2),\n    0,\n    Math.sin(params.rotation) * (params.depth / 2)\n  );\n  const y = vec3.fromValues(0, params.height / 2, 0);\n  const z = vec3.fromValues(\n    Math.sin(params.rotation) * (params.width / 2),\n    0,\n    -Math.cos(params.rotation) * (params.depth / 2)\n  );\n  const colors =\n    params.color instanceof Array\n      ? params.color\n      : new Array(6).fill(params.color);\n  const sign = (v: Vec3) => {\n    return params.type === 'concave' ? v : vec3.negate(v);\n  };\n  return [\n    {\n      // PositiveX\n      center: vec3.add(params.center, x),\n      right: sign(vec3.negate(z)),\n      up: y,\n      color: colors[CubeFace.PositiveX],\n    },\n    {\n      // PositiveY\n      center: vec3.add(params.center, y),\n      right: sign(x),\n      up: vec3.negate(z),\n      color: colors[CubeFace.PositiveY],\n    },\n    {\n      // PositiveZ\n      center: vec3.add(params.center, z),\n      right: sign(x),\n      up: y,\n      color: colors[CubeFace.PositiveZ],\n    },\n    {\n      // NegativeX\n      center: vec3.sub(params.center, x),\n      right: sign(z),\n      up: y,\n      color: colors[CubeFace.NegativeX],\n    },\n    {\n      // NegativeY\n      center: vec3.sub(params.center, y),\n      right: sign(x),\n      up: z,\n      color: colors[CubeFace.NegativeY],\n    },\n    {\n      // NegativeZ\n      center: vec3.sub(params.center, z),\n      right: sign(vec3.negate(x)),\n      up: y,\n      color: colors[CubeFace.NegativeZ],\n    },\n  ];\n}\n\nconst light: Quad = {\n  center: vec3.fromValues(0, 9.95, 0),\n  right: vec3.fromValues(1, 0, 0),\n  up: vec3.fromValues(0, 0, 1),\n  color: vec3.fromValues(5.0, 5.0, 5.0),\n  emissive: 1.0,\n};\n\n/**\n * Scene holds the cornell-box scene information.\n */\nexport default class Scene {\n  static sourceInfo = {\n    name: __filename.substring(__dirname.length + 1),\n    contents: __SOURCE__,\n  };\n\n  readonly vertexCount: number;\n  readonly indexCount: number;\n  readonly vertices: GPUBuffer;\n  readonly indices: GPUBuffer;\n  readonly vertexBufferLayout: GPUVertexBufferLayout[];\n  readonly quadBuffer: GPUBuffer;\n  readonly quads = [\n    ...box({\n      center: vec3.fromValues(0, 5, 0),\n      width: 10,\n      height: 10,\n      depth: 10,\n      rotation: 0,\n      color: [\n        vec3.fromValues(0.0, 0.5, 0.0), // PositiveX\n        vec3.fromValues(0.5, 0.5, 0.5), // PositiveY\n        vec3.fromValues(0.5, 0.5, 0.5), // PositiveZ\n        vec3.fromValues(0.5, 0.0, 0.0), // NegativeX\n        vec3.fromValues(0.5, 0.5, 0.5), // NegativeY\n        vec3.fromValues(0.5, 0.5, 0.5), // NegativeZ\n      ],\n      type: 'concave',\n    }),\n    ...box({\n      center: vec3.fromValues(1.5, 1.5, 1),\n      width: 3,\n      height: 3,\n      depth: 3,\n      rotation: 0.3,\n      color: vec3.fromValues(0.8, 0.8, 0.8),\n      type: 'convex',\n    }),\n    ...box({\n      center: vec3.fromValues(-2, 3, -2),\n      width: 3,\n      height: 6,\n      depth: 3,\n      rotation: -0.4,\n      color: vec3.fromValues(0.8, 0.8, 0.8),\n      type: 'convex',\n    }),\n    light,\n  ];\n  readonly lightCenter = light.center;\n  readonly lightWidth = vec3.len(light.right);\n  readonly lightHeight = vec3.len(light.up);\n\n  constructor(device: GPUDevice) {\n    const quadStride = 16 * 4;\n    const quadBuffer = device.createBuffer({\n      size: quadStride * this.quads.length,\n      usage: GPUBufferUsage.STORAGE,\n      mappedAtCreation: true,\n    });\n    const quadData = new Float32Array(quadBuffer.getMappedRange());\n    const vertexStride = 4 * 10;\n    const vertexData = new Float32Array(this.quads.length * vertexStride);\n    const indexData = new Uint32Array(this.quads.length * 9); // TODO: 6?\n    let vertexCount = 0;\n    let indexCount = 0;\n    let quadDataOffset = 0;\n    let vertexDataOffset = 0;\n    let indexDataOffset = 0;\n    for (let quadIdx = 0; quadIdx < this.quads.length; quadIdx++) {\n      const quad = this.quads[quadIdx];\n      const normal = vec3.normalize(vec3.cross(quad.right, quad.up));\n      quadData[quadDataOffset++] = normal[0];\n      quadData[quadDataOffset++] = normal[1];\n      quadData[quadDataOffset++] = normal[2];\n      quadData[quadDataOffset++] = -vec3.dot(normal, quad.center);\n\n      const invRight = reciprocal(quad.right);\n      quadData[quadDataOffset++] = invRight[0];\n      quadData[quadDataOffset++] = invRight[1];\n      quadData[quadDataOffset++] = invRight[2];\n      quadData[quadDataOffset++] = -vec3.dot(invRight, quad.center);\n\n      const invUp = reciprocal(quad.up);\n      quadData[quadDataOffset++] = invUp[0];\n      quadData[quadDataOffset++] = invUp[1];\n      quadData[quadDataOffset++] = invUp[2];\n      quadData[quadDataOffset++] = -vec3.dot(invUp, quad.center);\n\n      quadData[quadDataOffset++] = quad.color[0];\n      quadData[quadDataOffset++] = quad.color[1];\n      quadData[quadDataOffset++] = quad.color[2];\n      quadData[quadDataOffset++] = quad.emissive ?? 0;\n\n      // a ----- b\n      // |       |\n      // |   m   |\n      // |       |\n      // c ----- d\n      const a = vec3.add(vec3.sub(quad.center, quad.right), quad.up);\n      const b = vec3.add(vec3.add(quad.center, quad.right), quad.up);\n      const c = vec3.sub(vec3.sub(quad.center, quad.right), quad.up);\n      const d = vec3.sub(vec3.add(quad.center, quad.right), quad.up);\n\n      vertexData[vertexDataOffset++] = a[0];\n      vertexData[vertexDataOffset++] = a[1];\n      vertexData[vertexDataOffset++] = a[2];\n      vertexData[vertexDataOffset++] = 1;\n      vertexData[vertexDataOffset++] = 0; // uv.x\n      vertexData[vertexDataOffset++] = 1; // uv.y\n      vertexData[vertexDataOffset++] = quadIdx;\n      vertexData[vertexDataOffset++] = quad.color[0] * (quad.emissive ?? 0);\n      vertexData[vertexDataOffset++] = quad.color[1] * (quad.emissive ?? 0);\n      vertexData[vertexDataOffset++] = quad.color[2] * (quad.emissive ?? 0);\n\n      vertexData[vertexDataOffset++] = b[0];\n      vertexData[vertexDataOffset++] = b[1];\n      vertexData[vertexDataOffset++] = b[2];\n      vertexData[vertexDataOffset++] = 1;\n      vertexData[vertexDataOffset++] = 1; // uv.x\n      vertexData[vertexDataOffset++] = 1; // uv.y\n      vertexData[vertexDataOffset++] = quadIdx;\n      vertexData[vertexDataOffset++] = quad.color[0] * (quad.emissive ?? 0);\n      vertexData[vertexDataOffset++] = quad.color[1] * (quad.emissive ?? 0);\n      vertexData[vertexDataOffset++] = quad.color[2] * (quad.emissive ?? 0);\n\n      vertexData[vertexDataOffset++] = c[0];\n      vertexData[vertexDataOffset++] = c[1];\n      vertexData[vertexDataOffset++] = c[2];\n      vertexData[vertexDataOffset++] = 1;\n      vertexData[vertexDataOffset++] = 0; // uv.x\n      vertexData[vertexDataOffset++] = 0; // uv.y\n      vertexData[vertexDataOffset++] = quadIdx;\n      vertexData[vertexDataOffset++] = quad.color[0] * (quad.emissive ?? 0);\n      vertexData[vertexDataOffset++] = quad.color[1] * (quad.emissive ?? 0);\n      vertexData[vertexDataOffset++] = quad.color[2] * (quad.emissive ?? 0);\n\n      vertexData[vertexDataOffset++] = d[0];\n      vertexData[vertexDataOffset++] = d[1];\n      vertexData[vertexDataOffset++] = d[2];\n      vertexData[vertexDataOffset++] = 1;\n      vertexData[vertexDataOffset++] = 1; // uv.x\n      vertexData[vertexDataOffset++] = 0; // uv.y\n      vertexData[vertexDataOffset++] = quadIdx;\n      vertexData[vertexDataOffset++] = quad.color[0] * (quad.emissive ?? 0);\n      vertexData[vertexDataOffset++] = quad.color[1] * (quad.emissive ?? 0);\n      vertexData[vertexDataOffset++] = quad.color[2] * (quad.emissive ?? 0);\n\n      indexData[indexDataOffset++] = vertexCount + 0; // a\n      indexData[indexDataOffset++] = vertexCount + 2; // c\n      indexData[indexDataOffset++] = vertexCount + 1; // b\n      indexData[indexDataOffset++] = vertexCount + 1; // b\n      indexData[indexDataOffset++] = vertexCount + 2; // c\n      indexData[indexDataOffset++] = vertexCount + 3; // d\n      indexCount += 6;\n      vertexCount += 4;\n    }\n\n    quadBuffer.unmap();\n\n    const vertices = device.createBuffer({\n      size: vertexData.byteLength,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true,\n    });\n    new Float32Array(vertices.getMappedRange()).set(vertexData);\n    vertices.unmap();\n\n    const indices = device.createBuffer({\n      size: indexData.byteLength,\n      usage: GPUBufferUsage.INDEX,\n      mappedAtCreation: true,\n    });\n    new Uint16Array(indices.getMappedRange()).set(indexData);\n    indices.unmap();\n\n    const vertexBufferLayout: GPUVertexBufferLayout[] = [\n      {\n        arrayStride: vertexStride,\n        attributes: [\n          {\n            // position\n            shaderLocation: 0,\n            offset: 0 * 4,\n            format: 'float32x4',\n          },\n          {\n            // uv\n            shaderLocation: 1,\n            offset: 4 * 4,\n            format: 'float32x3',\n          },\n          {\n            // color\n            shaderLocation: 2,\n            offset: 7 * 4,\n            format: 'float32x3',\n          },\n        ],\n      },\n    ];\n\n    this.vertexCount = vertexCount;\n    this.indexCount = indexCount;\n    this.vertices = vertices;\n    this.indices = indices;\n    this.vertexBufferLayout = vertexBufferLayout;\n    this.quadBuffer = quadBuffer;\n  }\n}\n"};class g{update(e){let n=l._E.perspective(2*Math.PI/8,e.aspect,.5,100),t=e.rotateCamera?this.frame/1e3:0,a=l._E.lookAt(l.R3.fromValues(15*Math.sin(t),5,15*Math.cos(t)),l.R3.fromValues(0,5,0),l.R3.fromValues(0,1,0));l._E.inverse(a,a);let r=l._E.multiply(n,a),i=l._E.invert(r),o=new Float32Array(this.uniformBuffer.size/4),s=new Uint32Array(o.buffer);for(let u=0;u<16;u++)o[u]=r[u];for(let c=0;c<16;c++)o[c+16]=i[c];s[32]=4294967295*Math.random(),s[33]=4294967295*Math.random(),s[34]=4294967295*Math.random(),this.device.queue.writeBuffer(this.uniformBuffer,0,o.buffer,o.byteOffset,o.byteLength),this.frame++}constructor(e,n){this.wgsl=d,this.frame=0,this.device=e,this.uniformBuffer=e.createBuffer({label:"Common.uniformBuffer",size:144,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});let t=e.createBindGroupLayout({label:"Common.bindGroupLayout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),a=e.createBindGroup({label:"Common.bindGroup",layout:t,entries:[{binding:0,resource:{buffer:this.uniformBuffer,offset:0,size:this.uniformBuffer.size}},{binding:1,resource:{buffer:n,offset:0,size:n.size}}]});this.uniforms={bindGroupLayout:t,bindGroup:a}}}g.sourceInfo={name:"src/sample/cornell/common.ts".substring(19),contents:"import { mat4, vec3 } from 'wgpu-matrix';\nimport commonWGSL from './common.wgsl';\n\n/**\n * Common holds the shared WGSL between the shaders, including the common uniform buffer.\n */\nexport default class Common {\n  static sourceInfo = {\n    name: __filename.substring(__dirname.length + 1),\n    contents: __SOURCE__,\n  };\n\n  /** The WGSL of the common shader */\n  readonly wgsl = commonWGSL;\n  /** The common uniform buffer bind group and layout */\n  readonly uniforms: {\n    bindGroupLayout: GPUBindGroupLayout;\n    bindGroup: GPUBindGroup;\n  };\n\n  private readonly device: GPUDevice;\n  private readonly uniformBuffer: GPUBuffer;\n\n  private frame = 0;\n\n  constructor(device: GPUDevice, quads: GPUBuffer) {\n    this.device = device;\n    this.uniformBuffer = device.createBuffer({\n      label: 'Common.uniformBuffer',\n      size:\n        0 + //\n        4 * 16 + // mvp\n        4 * 16 + // inv_mvp\n        4 * 4, // seed\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n\n    const bindGroupLayout = device.createBindGroupLayout({\n      label: 'Common.bindGroupLayout',\n      entries: [\n        {\n          // common_uniforms\n          binding: 0,\n          visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\n          buffer: { type: 'uniform' },\n        },\n        {\n          // quads\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' },\n        },\n      ],\n    });\n\n    const bindGroup = device.createBindGroup({\n      label: 'Common.bindGroup',\n      layout: bindGroupLayout,\n      entries: [\n        {\n          // common_uniforms\n          binding: 0,\n          resource: {\n            buffer: this.uniformBuffer,\n            offset: 0,\n            size: this.uniformBuffer.size,\n          },\n        },\n        {\n          // quads\n          binding: 1,\n          resource: {\n            buffer: quads,\n            offset: 0,\n            size: quads.size,\n          },\n        },\n      ],\n    });\n\n    this.uniforms = { bindGroupLayout, bindGroup };\n  }\n\n  /** Updates the uniform buffer data */\n  update(params: { rotateCamera: boolean; aspect: number }) {\n    const projectionMatrix = mat4.perspective(\n      (2 * Math.PI) / 8,\n      params.aspect,\n      0.5,\n      100\n    );\n\n    const viewRotation = params.rotateCamera ? this.frame / 1000 : 0;\n\n    const viewMatrix = mat4.lookAt(\n      vec3.fromValues(\n        Math.sin(viewRotation) * 15,\n        5,\n        Math.cos(viewRotation) * 15\n      ),\n      vec3.fromValues(0, 5, 0),\n      vec3.fromValues(0, 1, 0)\n    );\n    mat4.inverse(viewMatrix, viewMatrix);\n    const mvp = mat4.multiply(projectionMatrix, viewMatrix);\n    const invMVP = mat4.invert(mvp);\n\n    const uniformDataF32 = new Float32Array(this.uniformBuffer.size / 4);\n    const uniformDataU32 = new Uint32Array(uniformDataF32.buffer);\n    for (let i = 0; i < 16; i++) {\n      uniformDataF32[i] = mvp[i];\n    }\n    for (let i = 0; i < 16; i++) {\n      uniformDataF32[i + 16] = invMVP[i];\n    }\n    uniformDataU32[32] = 0xffffffff * Math.random();\n    uniformDataU32[33] = 0xffffffff * Math.random();\n    uniformDataU32[34] = 0xffffffff * Math.random();\n\n    this.device.queue.writeBuffer(\n      this.uniformBuffer,\n      0,\n      uniformDataF32.buffer,\n      uniformDataF32.byteOffset,\n      uniformDataF32.byteLength\n    );\n\n    this.frame++;\n  }\n}\n"};class v{run(e){this.accumulationMean+=this.kPhotonsPerFrame*this.kPhotonEnergy/this.kTotalLightmapTexels;let n=1/this.accumulationMean,t=this.accumulationMean>2*this.kAccumulationMeanMax?.5:1;this.accumulationMean*=t;let a=new Float32Array(this.uniformBuffer.size/4);a[0]=n,a[1]=t,a[2]=this.scene.lightWidth,a[3]=this.scene.lightHeight,a[4]=this.scene.lightCenter[0],a[5]=this.scene.lightCenter[1],a[6]=this.scene.lightCenter[2],this.device.queue.writeBuffer(this.uniformBuffer,0,a.buffer,a.byteOffset,a.byteLength);let r=e.beginComputePass();r.setBindGroup(0,this.common.uniforms.bindGroup),r.setBindGroup(1,this.bindGroup),r.setPipeline(this.radiosityPipeline),r.dispatchWorkgroups(this.kWorkgroupsPerFrame),r.setPipeline(this.accumulationToLightmapPipeline),r.dispatchWorkgroups(Math.ceil(v.lightmapWidth/this.kAccumulationToLightmapWorkgroupSizeX),Math.ceil(v.lightmapHeight/this.kAccumulationToLightmapWorkgroupSizeY),this.lightmap.depthOrArrayLayers),r.end()}constructor(e,n,t){this.kPhotonsPerWorkgroup=256,this.kWorkgroupsPerFrame=1024,this.kPhotonsPerFrame=this.kPhotonsPerWorkgroup*this.kWorkgroupsPerFrame,this.kPhotonEnergy=1e5,this.kAccumulationToLightmapWorkgroupSizeX=16,this.kAccumulationToLightmapWorkgroupSizeY=16,this.accumulationMean=0,this.kAccumulationMeanMax=268435456,this.device=e,this.common=n,this.scene=t,this.lightmap=e.createTexture({label:"Radiosity.lightmap",size:{width:v.lightmapWidth,height:v.lightmapHeight,depthOrArrayLayers:t.quads.length},format:v.lightmapFormat,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),this.accumulationBuffer=e.createBuffer({label:"Radiosity.accumulationBuffer",size:v.lightmapWidth*v.lightmapHeight*t.quads.length*16,usage:GPUBufferUsage.STORAGE}),this.kTotalLightmapTexels=v.lightmapWidth*v.lightmapHeight*t.quads.length,this.uniformBuffer=e.createBuffer({label:"Radiosity.uniformBuffer",size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});let a=e.createBindGroupLayout({label:"Radiosity.bindGroupLayout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:v.lightmapFormat,viewDimension:"2d-array"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});this.bindGroup=e.createBindGroup({label:"Radiosity.bindGroup",layout:a,entries:[{binding:0,resource:{buffer:this.accumulationBuffer,size:this.accumulationBuffer.size}},{binding:1,resource:this.lightmap.createView()},{binding:2,resource:{buffer:this.uniformBuffer,size:this.uniformBuffer.size}}]});let r=e.createShaderModule({code:o+n.wgsl}),i=e.createPipelineLayout({label:"Radiosity.accumulatePipelineLayout",bindGroupLayouts:[n.uniforms.bindGroupLayout,a]});this.radiosityPipeline=e.createComputePipeline({label:"Radiosity.radiosityPipeline",layout:i,compute:{module:r,entryPoint:"radiosity",constants:{PhotonsPerWorkgroup:this.kPhotonsPerWorkgroup,PhotonEnergy:this.kPhotonEnergy}}}),this.accumulationToLightmapPipeline=e.createComputePipeline({label:"Radiosity.accumulationToLightmapPipeline",layout:i,compute:{module:r,entryPoint:"accumulation_to_lightmap",constants:{AccumulationToLightmapWorkgroupSizeX:this.kAccumulationToLightmapWorkgroupSizeX,AccumulationToLightmapWorkgroupSizeY:this.kAccumulationToLightmapWorkgroupSizeY}}})}}v.sourceInfo={name:"src/sample/cornell/radiosity.ts".substring(19),contents:"import Common from './common';\nimport radiosityWGSL from './radiosity.wgsl';\nimport Scene from './scene';\n\n/**\n * Radiosity computes lightmaps, calculated by software raytracing of light in\n * the scene.\n */\nexport default class Radiosity {\n  static sourceInfo = {\n    name: __filename.substring(__dirname.length + 1),\n    contents: __SOURCE__,\n  };\n\n  // The output lightmap format and dimensions\n  static readonly lightmapFormat = 'rgba16float';\n  static readonly lightmapWidth = 256;\n  static readonly lightmapHeight = 256;\n\n  // The output lightmap.\n  readonly lightmap: GPUTexture;\n\n  // Number of photons emitted per workgroup.\n  // This is equal to the workgroup size (one photon per invocation)\n  private readonly kPhotonsPerWorkgroup = 256;\n  // Number of radiosity workgroups dispatched per frame.\n  private readonly kWorkgroupsPerFrame = 1024;\n  private readonly kPhotonsPerFrame =\n    this.kPhotonsPerWorkgroup * this.kWorkgroupsPerFrame;\n  // Maximum value that can be added to the 'accumulation' buffer, per photon,\n  // across all texels.\n  private readonly kPhotonEnergy = 100000;\n  // The total number of lightmap texels for all quads.\n  private readonly kTotalLightmapTexels;\n\n  private readonly kAccumulationToLightmapWorkgroupSizeX = 16;\n  private readonly kAccumulationToLightmapWorkgroupSizeY = 16;\n\n  private readonly device: GPUDevice;\n  private readonly common: Common;\n  private readonly scene: Scene;\n  private readonly radiosityPipeline: GPUComputePipeline;\n  private readonly accumulationToLightmapPipeline: GPUComputePipeline;\n  private readonly bindGroup: GPUBindGroup;\n  private readonly accumulationBuffer: GPUBuffer;\n  private readonly uniformBuffer: GPUBuffer;\n\n  // The 'accumulation' buffer average value\n  private accumulationMean = 0;\n\n  // The maximum value of 'accumulationAverage' before all values in\n  // 'accumulation' are reduced to avoid integer overflows.\n  private readonly kAccumulationMeanMax = 0x10000000;\n\n  constructor(device: GPUDevice, common: Common, scene: Scene) {\n    this.device = device;\n    this.common = common;\n    this.scene = scene;\n    this.lightmap = device.createTexture({\n      label: 'Radiosity.lightmap',\n      size: {\n        width: Radiosity.lightmapWidth,\n        height: Radiosity.lightmapHeight,\n        depthOrArrayLayers: scene.quads.length,\n      },\n      format: Radiosity.lightmapFormat,\n      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,\n    });\n    this.accumulationBuffer = device.createBuffer({\n      label: 'Radiosity.accumulationBuffer',\n      size:\n        Radiosity.lightmapWidth *\n        Radiosity.lightmapHeight *\n        scene.quads.length *\n        16,\n      usage: GPUBufferUsage.STORAGE,\n    });\n    this.kTotalLightmapTexels =\n      Radiosity.lightmapWidth * Radiosity.lightmapHeight * scene.quads.length;\n    this.uniformBuffer = device.createBuffer({\n      label: 'Radiosity.uniformBuffer',\n      size: 8 * 4, // 8 x f32\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const bindGroupLayout = device.createBindGroupLayout({\n      label: 'Radiosity.bindGroupLayout',\n      entries: [\n        {\n          // accumulation buffer\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' },\n        },\n        {\n          // lightmap\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'write-only',\n            format: Radiosity.lightmapFormat,\n            viewDimension: '2d-array',\n          },\n        },\n        {\n          // radiosity_uniforms\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'uniform' },\n        },\n      ],\n    });\n    this.bindGroup = device.createBindGroup({\n      label: 'Radiosity.bindGroup',\n      layout: bindGroupLayout,\n      entries: [\n        {\n          // accumulation buffer\n          binding: 0,\n          resource: {\n            buffer: this.accumulationBuffer,\n            size: this.accumulationBuffer.size,\n          },\n        },\n        {\n          // lightmap\n          binding: 1,\n          resource: this.lightmap.createView(),\n        },\n        {\n          // radiosity_uniforms\n          binding: 2,\n          resource: {\n            buffer: this.uniformBuffer,\n            size: this.uniformBuffer.size,\n          },\n        },\n      ],\n    });\n\n    const mod = device.createShaderModule({\n      code: radiosityWGSL + common.wgsl,\n    });\n    const pipelineLayout = device.createPipelineLayout({\n      label: 'Radiosity.accumulatePipelineLayout',\n      bindGroupLayouts: [common.uniforms.bindGroupLayout, bindGroupLayout],\n    });\n\n    this.radiosityPipeline = device.createComputePipeline({\n      label: 'Radiosity.radiosityPipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: mod,\n        entryPoint: 'radiosity',\n        constants: {\n          PhotonsPerWorkgroup: this.kPhotonsPerWorkgroup,\n          PhotonEnergy: this.kPhotonEnergy,\n        },\n      },\n    });\n\n    this.accumulationToLightmapPipeline = device.createComputePipeline({\n      label: 'Radiosity.accumulationToLightmapPipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: mod,\n        entryPoint: 'accumulation_to_lightmap',\n        constants: {\n          AccumulationToLightmapWorkgroupSizeX:\n            this.kAccumulationToLightmapWorkgroupSizeX,\n          AccumulationToLightmapWorkgroupSizeY:\n            this.kAccumulationToLightmapWorkgroupSizeY,\n        },\n      },\n    });\n  }\n\n  run(commandEncoder: GPUCommandEncoder) {\n    // Calculate the new mean value for the accumulation buffer\n    this.accumulationMean +=\n      (this.kPhotonsPerFrame * this.kPhotonEnergy) / this.kTotalLightmapTexels;\n\n    // Calculate the 'accumulation' -> 'lightmap' scale factor from 'accumulationMean'\n    const accumulationToLightmapScale = 1 / this.accumulationMean;\n    // If 'accumulationMean' is greater than 'kAccumulationMeanMax', then reduce\n    // the 'accumulation' buffer values to prevent u32 overflow.\n    const accumulationBufferScale =\n      this.accumulationMean > 2 * this.kAccumulationMeanMax ? 0.5 : 1;\n    this.accumulationMean *= accumulationBufferScale;\n\n    // Update the radiosity uniform buffer data.\n    const uniformDataF32 = new Float32Array(this.uniformBuffer.size / 4);\n    uniformDataF32[0] = accumulationToLightmapScale;\n    uniformDataF32[1] = accumulationBufferScale;\n    uniformDataF32[2] = this.scene.lightWidth;\n    uniformDataF32[3] = this.scene.lightHeight;\n    uniformDataF32[4] = this.scene.lightCenter[0];\n    uniformDataF32[5] = this.scene.lightCenter[1];\n    uniformDataF32[6] = this.scene.lightCenter[2];\n    this.device.queue.writeBuffer(\n      this.uniformBuffer,\n      0,\n      uniformDataF32.buffer,\n      uniformDataF32.byteOffset,\n      uniformDataF32.byteLength\n    );\n\n    // Dispatch the radiosity workgroups\n    const passEncoder = commandEncoder.beginComputePass();\n    passEncoder.setBindGroup(0, this.common.uniforms.bindGroup);\n    passEncoder.setBindGroup(1, this.bindGroup);\n    passEncoder.setPipeline(this.radiosityPipeline);\n    passEncoder.dispatchWorkgroups(this.kWorkgroupsPerFrame);\n\n    // Then copy the 'accumulation' data to 'lightmap'\n    passEncoder.setPipeline(this.accumulationToLightmapPipeline);\n    passEncoder.dispatchWorkgroups(\n      Math.ceil(\n        Radiosity.lightmapWidth / this.kAccumulationToLightmapWorkgroupSizeX\n      ),\n      Math.ceil(\n        Radiosity.lightmapHeight / this.kAccumulationToLightmapWorkgroupSizeY\n      ),\n      this.lightmap.depthOrArrayLayers\n    );\n    passEncoder.end();\n  }\n}\n"},v.lightmapFormat="rgba16float",v.lightmapWidth=256,v.lightmapHeight=256;class b{run(e){let n=e.beginRenderPass(this.renderPassDescriptor);n.setPipeline(this.pipeline),n.setVertexBuffer(0,this.scene.vertices),n.setIndexBuffer(this.scene.indices,"uint16"),n.setBindGroup(0,this.common.uniforms.bindGroup),n.setBindGroup(1,this.bindGroup),n.drawIndexed(this.scene.indexCount),n.end()}constructor(e,n,t,a,r){this.common=n,this.scene=t;let i=e.createTexture({label:"RasterizerRenderer.depthTexture",size:[r.width,r.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});this.renderPassDescriptor={label:"RasterizerRenderer.renderPassDescriptor",colorAttachments:[{view:r.createView(),clearValue:[.1,.2,.3,1],loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:i.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};let o=e.createBindGroupLayout({label:"RasterizerRenderer.bindGroupLayout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,sampler:{}}]});this.bindGroup=e.createBindGroup({label:"RasterizerRenderer.bindGroup",layout:o,entries:[{binding:0,resource:a.lightmap.createView()},{binding:1,resource:e.createSampler({addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",magFilter:"linear",minFilter:"linear"})}]});let u=e.createShaderModule({label:"RasterizerRenderer.module",code:s+n.wgsl});this.pipeline=e.createRenderPipeline({label:"RasterizerRenderer.pipeline",layout:e.createPipelineLayout({bindGroupLayouts:[n.uniforms.bindGroupLayout,o]}),vertex:{module:u,entryPoint:"vs_main",buffers:t.vertexBufferLayout},fragment:{module:u,entryPoint:"fs_main",targets:[{format:r.format}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}})}}b.sourceInfo={name:"src/sample/cornell/rasterizer.ts".substring(19),contents:"import rasterizerWGSL from './rasterizer.wgsl';\n\nimport Common from './common';\nimport Radiosity from './radiosity';\nimport Scene from './scene';\n\n/**\n * Rasterizer renders the scene using a regular raserization graphics pipeline.\n */\nexport default class Rasterizer {\n  static sourceInfo = {\n    name: __filename.substring(__dirname.length + 1),\n    contents: __SOURCE__,\n  };\n\n  private readonly common: Common;\n  private readonly scene: Scene;\n  private readonly renderPassDescriptor: GPURenderPassDescriptor;\n  private readonly pipeline: GPURenderPipeline;\n  private readonly bindGroup: GPUBindGroup;\n\n  constructor(\n    device: GPUDevice,\n    common: Common,\n    scene: Scene,\n    radiosity: Radiosity,\n    framebuffer: GPUTexture\n  ) {\n    this.common = common;\n    this.scene = scene;\n\n    const depthTexture = device.createTexture({\n      label: 'RasterizerRenderer.depthTexture',\n      size: [framebuffer.width, framebuffer.height],\n      format: 'depth24plus',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    this.renderPassDescriptor = {\n      label: 'RasterizerRenderer.renderPassDescriptor',\n      colorAttachments: [\n        {\n          view: framebuffer.createView(),\n          clearValue: [0.1, 0.2, 0.3, 1],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n      depthStencilAttachment: {\n        view: depthTexture.createView(),\n        depthClearValue: 1.0,\n        depthLoadOp: 'clear',\n        depthStoreOp: 'store',\n      },\n    };\n\n    const bindGroupLayout = device.createBindGroupLayout({\n      label: 'RasterizerRenderer.bindGroupLayout',\n      entries: [\n        {\n          // lightmap\n          binding: 0,\n          visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,\n          texture: { viewDimension: '2d-array' },\n        },\n        {\n          // sampler\n          binding: 1,\n          visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,\n          sampler: {},\n        },\n      ],\n    });\n\n    this.bindGroup = device.createBindGroup({\n      label: 'RasterizerRenderer.bindGroup',\n      layout: bindGroupLayout,\n      entries: [\n        {\n          // lightmap\n          binding: 0,\n          resource: radiosity.lightmap.createView(),\n        },\n        {\n          // sampler\n          binding: 1,\n          resource: device.createSampler({\n            addressModeU: 'clamp-to-edge',\n            addressModeV: 'clamp-to-edge',\n            magFilter: 'linear',\n            minFilter: 'linear',\n          }),\n        },\n      ],\n    });\n\n    const mod = device.createShaderModule({\n      label: 'RasterizerRenderer.module',\n      code: rasterizerWGSL + common.wgsl,\n    });\n\n    this.pipeline = device.createRenderPipeline({\n      label: 'RasterizerRenderer.pipeline',\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [common.uniforms.bindGroupLayout, bindGroupLayout],\n      }),\n      vertex: {\n        module: mod,\n        entryPoint: 'vs_main',\n        buffers: scene.vertexBufferLayout,\n      },\n      fragment: {\n        module: mod,\n        entryPoint: 'fs_main',\n        targets: [{ format: framebuffer.format }],\n      },\n      primitive: {\n        topology: 'triangle-list',\n        cullMode: 'back',\n      },\n      depthStencil: {\n        depthWriteEnabled: true,\n        depthCompare: 'less',\n        format: 'depth24plus',\n      },\n    });\n  }\n\n  run(commandEncoder: GPUCommandEncoder) {\n    const passEncoder = commandEncoder.beginRenderPass(\n      this.renderPassDescriptor\n    );\n    passEncoder.setPipeline(this.pipeline);\n    passEncoder.setVertexBuffer(0, this.scene.vertices);\n    passEncoder.setIndexBuffer(this.scene.indices, 'uint16');\n    passEncoder.setBindGroup(0, this.common.uniforms.bindGroup);\n    passEncoder.setBindGroup(1, this.bindGroup);\n    passEncoder.drawIndexed(this.scene.indexCount);\n    passEncoder.end();\n  }\n}\n"};class y{run(e){let n=e.beginComputePass();n.setBindGroup(0,this.bindGroup),n.setPipeline(this.pipeline),n.dispatchWorkgroups(Math.ceil(this.width/this.kWorkgroupSizeX),Math.ceil(this.height/this.kWorkgroupSizeY)),n.end()}constructor(e,n,t,a){this.kWorkgroupSizeX=16,this.kWorkgroupSizeY=16,this.width=t.width,this.height=t.height;let r=e.createBindGroupLayout({label:"Tonemapper.bindGroupLayout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:a.format,viewDimension:"2d"}}]});this.bindGroup=e.createBindGroup({label:"Tonemapper.bindGroup",layout:r,entries:[{binding:0,resource:t.createView()},{binding:1,resource:a.createView()}]});let i=e.createShaderModule({code:c.replace("{OUTPUT_FORMAT}",a.format)+n.wgsl}),o=e.createPipelineLayout({label:"Tonemap.pipelineLayout",bindGroupLayouts:[r]});this.pipeline=e.createComputePipeline({label:"Tonemap.pipeline",layout:o,compute:{module:i,entryPoint:"main",constants:{WorkgroupSizeX:this.kWorkgroupSizeX,WorkgroupSizeY:this.kWorkgroupSizeY}}})}}y.sourceInfo={name:"src/sample/cornell/tonemapper.ts".substring(19),contents:"import Common from './common';\nimport tonemapperWGSL from './tonemapper.wgsl';\n\n/**\n * Tonemapper implements a tonemapper to convert a linear-light framebuffer to\n * a gamma-correct, tonemapped framebuffer used for presentation.\n */\nexport default class Tonemapper {\n  static sourceInfo = {\n    name: __filename.substring(__dirname.length + 1),\n    contents: __SOURCE__,\n  };\n\n  private readonly bindGroup: GPUBindGroup;\n  private readonly pipeline: GPUComputePipeline;\n  private readonly width: number;\n  private readonly height: number;\n  private readonly kWorkgroupSizeX = 16;\n  private readonly kWorkgroupSizeY = 16;\n\n  constructor(\n    device: GPUDevice,\n    common: Common,\n    input: GPUTexture,\n    output: GPUTexture\n  ) {\n    this.width = input.width;\n    this.height = input.height;\n    const bindGroupLayout = device.createBindGroupLayout({\n      label: 'Tonemapper.bindGroupLayout',\n      entries: [\n        {\n          // input\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          texture: {\n            viewDimension: '2d',\n          },\n        },\n        {\n          // output\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'write-only',\n            format: output.format,\n            viewDimension: '2d',\n          },\n        },\n      ],\n    });\n    this.bindGroup = device.createBindGroup({\n      label: 'Tonemapper.bindGroup',\n      layout: bindGroupLayout,\n      entries: [\n        {\n          // input\n          binding: 0,\n          resource: input.createView(),\n        },\n        {\n          // output\n          binding: 1,\n          resource: output.createView(),\n        },\n      ],\n    });\n\n    const mod = device.createShaderModule({\n      code:\n        tonemapperWGSL.replace('{OUTPUT_FORMAT}', output.format) + common.wgsl,\n    });\n    const pipelineLayout = device.createPipelineLayout({\n      label: 'Tonemap.pipelineLayout',\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    this.pipeline = device.createComputePipeline({\n      label: 'Tonemap.pipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: mod,\n        entryPoint: 'main',\n        constants: {\n          WorkgroupSizeX: this.kWorkgroupSizeX,\n          WorkgroupSizeY: this.kWorkgroupSizeY,\n        },\n      },\n    });\n  }\n\n  run(commandEncoder: GPUCommandEncoder) {\n    const passEncoder = commandEncoder.beginComputePass();\n    passEncoder.setBindGroup(0, this.bindGroup);\n    passEncoder.setPipeline(this.pipeline);\n    passEncoder.dispatchWorkgroups(\n      Math.ceil(this.width / this.kWorkgroupSizeX),\n      Math.ceil(this.height / this.kWorkgroupSizeY)\n    );\n    passEncoder.end();\n  }\n}\n"};class x{run(e){let n=e.beginComputePass();n.setPipeline(this.pipeline),n.setBindGroup(0,this.common.uniforms.bindGroup),n.setBindGroup(1,this.bindGroup),n.dispatchWorkgroups(this.framebuffer.width/this.kWorkgroupSizeX,this.framebuffer.height/this.kWorkgroupSizeY),n.end()}constructor(e,n,t,a){this.kWorkgroupSizeX=16,this.kWorkgroupSizeY=16,this.common=n,this.framebuffer=a;let r=e.createBindGroupLayout({label:"Raytracer.bindGroupLayout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{viewDimension:"2d-array"}},{binding:1,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,sampler:{}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:a.format,viewDimension:"2d"}}]});this.bindGroup=e.createBindGroup({label:"rendererBindGroup",layout:r,entries:[{binding:0,resource:t.lightmap.createView()},{binding:1,resource:e.createSampler({addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge",magFilter:"linear",minFilter:"linear"})},{binding:2,resource:a.createView()}]}),this.pipeline=e.createComputePipeline({label:"raytracerPipeline",layout:e.createPipelineLayout({bindGroupLayouts:[n.uniforms.bindGroupLayout,r]}),compute:{module:e.createShaderModule({code:u+n.wgsl}),entryPoint:"main",constants:{WorkgroupSizeX:this.kWorkgroupSizeX,WorkgroupSizeY:this.kWorkgroupSizeY}}})}}x.sourceInfo={name:"src/sample/cornell/raytracer.ts".substring(19),contents:"import raytracerWGSL from './raytracer.wgsl';\n\nimport Common from './common';\nimport Radiosity from './radiosity';\n\n/**\n * Raytracer renders the scene using a software ray-tracing compute pipeline.\n */\nexport default class Raytracer {\n  static sourceInfo = {\n    name: __filename.substring(__dirname.length + 1),\n    contents: __SOURCE__,\n  };\n\n  private readonly common: Common;\n  private readonly framebuffer: GPUTexture;\n  private readonly pipeline: GPUComputePipeline;\n  private readonly bindGroup: GPUBindGroup;\n\n  private readonly kWorkgroupSizeX = 16;\n  private readonly kWorkgroupSizeY = 16;\n\n  constructor(\n    device: GPUDevice,\n    common: Common,\n    radiosity: Radiosity,\n    framebuffer: GPUTexture\n  ) {\n    this.common = common;\n    this.framebuffer = framebuffer;\n    const bindGroupLayout = device.createBindGroupLayout({\n      label: 'Raytracer.bindGroupLayout',\n      entries: [\n        {\n          // lightmap\n          binding: 0,\n          visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,\n          texture: { viewDimension: '2d-array' },\n        },\n        {\n          // sampler\n          binding: 1,\n          visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,\n          sampler: {},\n        },\n        {\n          // framebuffer\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'write-only',\n            format: framebuffer.format,\n            viewDimension: '2d',\n          },\n        },\n      ],\n    });\n\n    this.bindGroup = device.createBindGroup({\n      label: 'rendererBindGroup',\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: radiosity.lightmap.createView(),\n        },\n        {\n          binding: 1,\n          resource: device.createSampler({\n            addressModeU: 'clamp-to-edge',\n            addressModeV: 'clamp-to-edge',\n            addressModeW: 'clamp-to-edge',\n            magFilter: 'linear',\n            minFilter: 'linear',\n          }),\n        },\n        {\n          binding: 2,\n          resource: framebuffer.createView(),\n        },\n      ],\n    });\n\n    this.pipeline = device.createComputePipeline({\n      label: 'raytracerPipeline',\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [common.uniforms.bindGroupLayout, bindGroupLayout],\n      }),\n      compute: {\n        module: device.createShaderModule({\n          code: raytracerWGSL + common.wgsl,\n        }),\n        entryPoint: 'main',\n        constants: {\n          WorkgroupSizeX: this.kWorkgroupSizeX,\n          WorkgroupSizeY: this.kWorkgroupSizeY,\n        },\n      },\n    });\n  }\n\n  run(commandEncoder: GPUCommandEncoder) {\n    const passEncoder = commandEncoder.beginComputePass();\n    passEncoder.setPipeline(this.pipeline);\n    passEncoder.setBindGroup(0, this.common.uniforms.bindGroup);\n    passEncoder.setBindGroup(1, this.bindGroup);\n    passEncoder.dispatchWorkgroups(\n      this.framebuffer.width / this.kWorkgroupSizeX,\n      this.framebuffer.height / this.kWorkgroupSizeY\n    );\n    passEncoder.end();\n  }\n}\n"};var P="src/sample/cornell/main.ts";let G=async e=>{let{canvas:n,pageState:t,gui:a}=e,r=navigator.gpu.getPreferredCanvasFormat(),i="bgra8unorm"===r?["bgra8unorm-storage"]:[],o=await navigator.gpu.requestAdapter();for(let s of i)if(!o.features.has(s))throw Error("sample requires ".concat(s,", but is not supported by the adapter"));let u=await o.requestDevice({requiredFeatures:i});if(!t.active)return;let c={renderer:"rasterizer",rotateCamera:!0};a.add(c,"renderer",["rasterizer","raytracer"]),a.add(c,"rotateCamera",!0);let d=window.devicePixelRatio||1;n.width=n.clientWidth*d,n.height=n.clientHeight*d;let l=n.getContext("webgpu");l.configure({device:u,format:r,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});let m=u.createTexture({label:"framebuffer",size:[n.width,n.height],format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),p=new h(u),f=new g(u,p.quadBuffer),P=new v(u,f,p),G=new b(u,f,p,P,m),_=new x(u,f,P,m);requestAnimationFrame(function e(){if(!t.active)return;let a=l.getCurrentTexture(),r=u.createCommandEncoder();switch(f.update({rotateCamera:c.rotateCamera,aspect:n.width/n.height}),P.run(r),c.renderer){case"rasterizer":G.run(r);break;case"raytracer":_.run(r)}let i=new y(u,f,m,a);i.run(r),u.queue.submit([r.finish()]),requestAnimationFrame(e)})},_=()=>(0,i.T)({name:"Cornell box",description:"A classic Cornell box, using a lightmap generated using software ray-tracing.",gui:!0,init:G,sources:[{name:P.substring(19),contents:"import { makeSample, SampleInit } from '../../components/SampleLayout';\n\nimport radiosityWGSL from './radiosity.wgsl';\nimport rasterizerWGSL from './rasterizer.wgsl';\nimport raytracerWGSL from './raytracer.wgsl';\nimport tonemapperWGSL from './tonemapper.wgsl';\nimport commonWGSL from './common.wgsl';\nimport Scene from './scene';\nimport Common from './common';\nimport Radiosity from './radiosity';\nimport Rasterizer from './rasterizer';\nimport Tonemapper from './tonemapper';\nimport Raytracer from './raytracer';\n\nconst init: SampleInit = async ({ canvas, pageState, gui }) => {\n  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n  const requiredFeatures: GPUFeatureName[] =\n    presentationFormat === 'bgra8unorm' ? ['bgra8unorm-storage'] : [];\n  const adapter = await navigator.gpu.requestAdapter();\n  for (const feature of requiredFeatures) {\n    if (!adapter.features.has(feature)) {\n      throw new Error(\n        `sample requires ${feature}, but is not supported by the adapter`\n      );\n    }\n  }\n  const device = await adapter.requestDevice({ requiredFeatures });\n\n  if (!pageState.active) return;\n\n  const params: {\n    renderer: 'rasterizer' | 'raytracer';\n    rotateCamera: boolean;\n  } = {\n    renderer: 'rasterizer',\n    rotateCamera: true,\n  };\n\n  gui.add(params, 'renderer', ['rasterizer', 'raytracer']);\n  gui.add(params, 'rotateCamera', true);\n\n  const devicePixelRatio = window.devicePixelRatio || 1;\n  canvas.width = canvas.clientWidth * devicePixelRatio;\n  canvas.height = canvas.clientHeight * devicePixelRatio;\n\n  const context = canvas.getContext('webgpu') as GPUCanvasContext;\n  context.configure({\n    device,\n    format: presentationFormat,\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,\n    alphaMode: 'premultiplied',\n  });\n\n  const framebuffer = device.createTexture({\n    label: 'framebuffer',\n    size: [canvas.width, canvas.height],\n    format: 'rgba16float',\n    usage:\n      GPUTextureUsage.RENDER_ATTACHMENT |\n      GPUTextureUsage.STORAGE_BINDING |\n      GPUTextureUsage.TEXTURE_BINDING,\n  });\n\n  const scene = new Scene(device);\n  const common = new Common(device, scene.quadBuffer);\n  const radiosity = new Radiosity(device, common, scene);\n  const rasterizer = new Rasterizer(\n    device,\n    common,\n    scene,\n    radiosity,\n    framebuffer\n  );\n  const raytracer = new Raytracer(device, common, radiosity, framebuffer);\n\n  function frame() {\n    if (!pageState.active) {\n      // Sample is no longer the active page.\n      return;\n    }\n\n    const canvasTexture = context.getCurrentTexture();\n    const commandEncoder = device.createCommandEncoder();\n\n    common.update({\n      rotateCamera: params.rotateCamera,\n      aspect: canvas.width / canvas.height,\n    });\n    radiosity.run(commandEncoder);\n\n    switch (params.renderer) {\n      case 'rasterizer': {\n        rasterizer.run(commandEncoder);\n        break;\n      }\n      case 'raytracer': {\n        raytracer.run(commandEncoder);\n        break;\n      }\n    }\n\n    const tonemapper = new Tonemapper(\n      device,\n      common,\n      framebuffer,\n      canvasTexture\n    );\n    tonemapper.run(commandEncoder);\n\n    device.queue.submit([commandEncoder.finish()]);\n\n    requestAnimationFrame(frame);\n  }\n\n  requestAnimationFrame(frame);\n};\n\nconst CornellBox: () => JSX.Element = () =>\n  makeSample({\n    name: 'Cornell box',\n    description:\n      'A classic Cornell box, using a lightmap generated using software ray-tracing.',\n    gui: true,\n    init,\n    sources: [\n      {\n        name: __filename.substring(__dirname.length + 1),\n        contents: __SOURCE__,\n      },\n      Common.sourceInfo,\n      Scene.sourceInfo,\n      Radiosity.sourceInfo,\n      Rasterizer.sourceInfo,\n      Raytracer.sourceInfo,\n      Tonemapper.sourceInfo,\n      {\n        name: './radiosity.wgsl',\n        contents: radiosityWGSL,\n        editable: true,\n      },\n      {\n        name: './rasterizer.wgsl',\n        contents: rasterizerWGSL,\n        editable: true,\n      },\n      {\n        name: './raytracer.wgsl',\n        contents: raytracerWGSL,\n        editable: true,\n      },\n      {\n        name: './tonemapper.wgsl',\n        contents: tonemapperWGSL,\n        editable: true,\n      },\n      {\n        name: './common.wgsl',\n        contents: commonWGSL,\n        editable: true,\n      },\n    ],\n    filename: __filename,\n  });\n\nexport default CornellBox;\n"},g.sourceInfo,h.sourceInfo,v.sourceInfo,b.sourceInfo,x.sourceInfo,y.sourceInfo,{name:"./radiosity.wgsl",contents:o,editable:!0},{name:"./rasterizer.wgsl",contents:s,editable:!0},{name:"./raytracer.wgsl",contents:u,editable:!0},{name:"./tonemapper.wgsl",contents:c,editable:!0},{name:"./common.wgsl",contents:d,editable:!0}],filename:P});var S=_},9147:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__zRR_l",sourceFileNav:"SampleLayout_sourceFileNav__ml48P",sourceFileContainer:"SampleLayout_sourceFileContainer__3s84x"}}}]);